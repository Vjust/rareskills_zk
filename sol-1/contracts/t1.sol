// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;


// (
//    
//[10857046999023057135944570762232829481370756359578518086990519993285655852781, 11559732032986387107991004021392285783925812861821192530917403151452391805634]
//[10857046999023057135944570762232829481370756359578518086990519993285655852781, 11559732032986387107991004021392285783925812861821192530917403151452391805634] 
// [8495653923123431417604973247489272438418190587263600148770280649306958101930, 4082367875863433681332203403145435568316851327593401208105741076214120093531]
//[8495653923123431417604973247489272438418190587263600148770280649306958101930, 4082367875863433681332203403145435568316851327593401208105741076214120093531]

//[10857046999023057135944570762232829481370756359578518086990519993285655852781, 11559732032986387107991004021392285783925812861821192530917403151452391805634]
contract ECPairing {
    address constant PAIRING_PRECOMPILE = address(8);

    struct G1 {
        uint256 x;
        uint256 y;
    }

    struct G2 {
        uint256 x1;
        uint256 x1_im;
        uint256 y1;
        uint256 y1_im;
    }

    uint256 constant p = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    function verify(G1 memory A, G2 memory B, G1 memory C,  G2 memory D ) public returns (bool) {
        uint256 inv_A_y = p - A.y;
        G1 memory inv_A = G1(A.x, inv_A_y);

        bytes memory payload = abi.encode(inv_A.x, inv_A.y, B.x1, B.x1_im, B.y1, B.y1_im, C.x, C.y, D.x1, D.x1_im, D.y1, D.y1_im);   
        (bool success, bytes memory result) = PAIRING_PRECOMPILE.staticcall(payload);

        require(success);

        bool result_bool = abi.decode(result, (bool));
        return result_bool;
    }
}