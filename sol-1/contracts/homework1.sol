
// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.8.2 <0.9.0;

contract HomeWork1 {

	struct ECPoint {
	uint256 x;
	uint256 y;
}

 


function rationalAdd(ECPoint calldata A, ECPoint calldata B, uint256 num, uint256 den) public view returns (bool verified) {
	
	// return true if the prover knows two numbers that add up to num/den

    if ( address(6) ( address(7) (A.x, B.y, curve_order)  , address(7) (B.x, A.y, curve_order)) == num)
	and (  address7( B.y, A.y) == den) 
		return True
	return False
}

p1/q1 , p2/q2 p1q2 + p2q1/q1q2 , num == p2q1 + p1q2  den == q1q2


function matmul(uint256[] calldata matrix,
                uint256 n, // n x n for the matrix
                ECPoint[] calldata s, // n elements
                uint256[] calldata o // n elements
               ) public returns (bool verified) {

	// revert if dimensions don't make sense or the matrices are empty

	// return true if Ms == o elementwise. You need to do n equality checks. If you're lazy, you can hardcode n to 3, but it is suggested that you do this with a for loop 
}


}


