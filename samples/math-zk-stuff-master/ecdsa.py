# import py_ecc.secp256k1 as secp256k1
import hashlib
import secrets

# secp256k1 curve parameters
# Field prime
P = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
# Curve coefficients (y^2 = x^3 + ax + b)
A = 0
B = 7
# Generator point (base point)
Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798
Gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8
G = (Gx, Gy)
# Order of the group generated by G
N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141

def get_inverse(a, p):
    return pow(a, p - 2, p)

# minimal implementation of ECDSA

def is_on_curve(point, p, a, b):
    if point is None:  # Point at infinity
        return True
    x, y = point
    return (y * y - (x * x * x + a * x + b)) % p == 0
  
def point_add(p1, p2, p, a, b):
    if p1 is None:
        return p2
    if p2 is None:
        return p1
    x1, y1 = p1
    x2, y2 = p2
    if x1 == x2:
        if (y1 + y2) % p == 0:
            return None
        else:
            l = ((3 * x1 * x1 + a) * get_inverse(2 * y1, p)) % p
    else:
        l = ((y2 - y1) * get_inverse(x2 - x1, p)) % p
    x3 = (l * l - x1 - x2) % p
    y3 = (l * (x1 - x3) - y1) % p
    return (x3, y3)

def point_multiply(point, scalar, p, a, b):
    result = None
    for i in range(scalar.bit_length()):
        if scalar & (1 << i):
            result = point_add(result, point, p, a, b)
        point = point_add(point, point, p, a, b)
    return result

def generate_keypair(private_key):
    if not is_on_curve(G, P, A, B):
        raise ValueError("Generator point is not on the curve")
    return point_multiply(G, private_key, P, A, B)

def sign_message(message, private_key):
    if not is_on_curve(G, P, A, B):
        raise ValueError("Generator point is not on the curve")
    hash_bytes = hashlib.sha256(message.encode()).digest()
    hash_int = int.from_bytes(hash_bytes, 'big')
    r = 0
    s = 0
    while r == 0 or s == 0: # ensure r and s are not zero
        k = secrets.randbelow(N-1) + 1
        R = point_multiply(G, k, P, A, B)
        r = R[0] % N
        s = ((hash_int + r * private_key) * get_inverse(k, N)) % N
    return (r, s)

def verify_signature(message, signature, public_key):
    if not is_on_curve(public_key, P, A, B):
        raise ValueError("Public key is not on the curve")
    hash_bytes = hashlib.sha256(message.encode()).digest()
    hash_int = int.from_bytes(hash_bytes, 'big')
    r, s = signature
    if r == 0 or s == 0:
        return False
    w = get_inverse(s, N)
    u1 = (hash_int * w) % N
    u2 = (r * w) % N
    R = point_add(point_multiply(G, u1, P, A, B), point_multiply(public_key, u2, P, A, B), P, A, B)
    return R[0] % N == r

# generate a private key
private_key = secrets.randbelow(N-1) +1
print("private key: ", private_key)

# generate a keypair
keypair = generate_keypair(private_key)
print("keypair: ", keypair)

# sign a message
message = "Hello, world!"
signature = sign_message(message, private_key)
print("signature: ", signature)

# verify a signature
print("signature is valid: ", verify_signature(message, signature, keypair))
